import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as p,c,a as e,b as n,d as s,e as a}from"./app-4bc45b34.js";const i="/DaMaiCoding-Note/assets/image-20240718143416540-6117f3ec.png",d="/DaMaiCoding-Note/assets/image-20240718143558442-56431b61.png",r="/DaMaiCoding-Note/assets/image-20240718143727862-3361e1c0.png",u={},h=a('<h1 id="_2025-前端最新面试题-项目篇" tabindex="-1"><a class="header-anchor" href="#_2025-前端最新面试题-项目篇" aria-hidden="true">#</a> 2025 前端最新面试题-项目篇</h1><h2 id="_1-从零创建一个-vue3-项目的步骤" tabindex="-1"><a class="header-anchor" href="#_1-从零创建一个-vue3-项目的步骤" aria-hidden="true">#</a> 1. 从零创建一个 Vue3 项目的步骤？</h2><ol><li><p>使用脚手架创建一个基础项目</p></li><li><p>使用 axios 做接口请求封装</p><ol><li>请求拦截器 -&gt; 为请求添加 token</li><li>响应拦截器 -&gt; 返回状态处理，做登录校验，无感刷新</li></ol></li><li><p>看项目情况，是否需要做动态路由，不需要的话就直接使用手脚架已经写好的默认路由即可</p></li><li><p>添加 store 目录，使用状态管理 pinia 或者 vuex 也行</p></li><li><p>定义自定义 hooks 目录，定义一些涉及组件变化的函数，定义 utils 目录定义一些纯函数，不具备响应式</p></li><li><p>创建 components 目录用于定义一些功能组件</p></li><li><p>当然啦，还是要看项目的具体情况，后台管理系统可以使用 layout 布局，以及做国际化的 locals 文件夹</p></li></ol><p><strong>视频是用什么格式的？</strong></p><p>使用 <code>flv</code> 格式的，<code>WebSocket</code> 去接收</p><p>本来想直接通过视像头提供商的云平台，使用他们提供的 <code>m3u8</code> 格式播放链接即可</p><p>使用 <code>html5</code> <code>&lt;video&gt;</code> 标签播放的</p><h2 id="_3-单点登录如何实现" tabindex="-1"><a class="header-anchor" href="#_3-单点登录如何实现" aria-hidden="true">#</a> 3. 单点登录如何实现</h2><p>一般有两种模式</p><ul><li>token + cookie</li><li>token + refreshToken</li></ul><p><strong>session + cookie 模式</strong></p><p>优点：这种模式具有很强的控制力，只要把认证中心的 session 删除，用户就能强制下线</p><p>缺点：烧钱，如果客户端用户多，那么相对的认证中心压力也就大了，里面的 session 表也大了，得做集群</p><p>认证中心也得保证不能蹦，还得考虑做容灾</p><figure><img src="'+i+'" alt="image-20240718143416540" tabindex="0" loading="lazy"><figcaption>image-20240718143416540</figcaption></figure><p><strong>token + refshToken 模式</strong></p><figure><img src="'+d+'" alt="image-20240718143558442" tabindex="0" loading="lazy"><figcaption>image-20240718143558442</figcaption></figure><p>token 时间有效时间短，过期后，可以通过 refreshToken 再次获取 token</p><p>因为 token 有效时间短，就得隔一段时间使用 refreshToken 去获取 token，这样认证中心就加强了，对客户端系统的控制力了</p><figure><img src="'+r+'" alt="image-20240718143727862" tabindex="0" loading="lazy"><figcaption>image-20240718143727862</figcaption></figure><p>优点：认证中心压力小了</p><p>缺点：没法立即让用户下线，得等用户来拿 token 的时候，不让他获取 token，从而实现用户下线</p><h2 id="_4-项目框架升级" tabindex="-1"><a class="header-anchor" href="#_4-项目框架升级" aria-hidden="true">#</a> 4. 项目框架升级</h2><p>Angular 1 替换为 Vue3 框架</p><p>使用 Angular 1 是为了兼容 ie</p><p>替换的方法：</p><p>Angular 1 的 js 都是放在 scope 中，所以需要将 scope 提炼成一个个 js 文件，并导入 vue 文件中即可</p><p>并且 Angular 1 的模板语法与 vue 类似，vue 是 v-if，angular 是 ng-if，所以只要稍微改造下就能替换为 vue 模板语法</p><h2 id="_5-你对接过哪些支付" tabindex="-1"><a class="header-anchor" href="#_5-你对接过哪些支付" aria-hidden="true">#</a> 5. 你对接过哪些支付？</h2><p>都要了解汇总</p><p>微信、支付宝、银联...</p><p>微信：</p><ul><li>PC（Native 扫码支付） 前端传给后端订单号 -&gt; 后端返回二维码（前端展示二维码） -&gt; 用户扫码后，自动调起微信支付 -&gt; 轮询查看订单状态（直到超时 60s, 2s 查一次，订单支付完成返回原页面）</li><li>H5 前端将订单信息发给后端 -&gt; 后端返回一个 url 链接 -&gt; 前端自动跳转到 url 链接调起微信支付 -&gt; 返回原来的页面 <ul><li>【扩展1】如果要指定支付完成后的指定页面，需要后端返回的链接中拼接指定页面的 url</li><li>【扩展2】如果是用户取消支付了，也会跳转到指定页面。那么指定页面就需要轮询根据订单信息进行显示，或者弹框提示</li></ul></li><li>微信小程序 <ul><li>前端将订单信息发送给后端 -&gt; 后端返回<code>uni.requestPayment</code>所需数据 -&gt; 前端调用 <code>uni.requestPayment</code>-&gt; 支付成功后</li><li><code>provider：&#39;wxpay&#39;</code></li></ul></li><li>APP <ul><li>前端将订单信息发送给后端 -&gt; 后端返回<code>uni.requestPayment</code>所需数据 -&gt; 前端调用 <code>uni.requestPayment</code>-&gt; 支付成功后</li><li><code>provider：&#39;wxpay&#39;</code></li></ul></li></ul><p>支付宝：</p><ul><li>PC <ol><li>前置模式（生成二维码到页面里,用户进行扫码支付） <ol><li>通过后端提供的接口获取支付宝的数据 ----&gt; 调用接口获取支付宝的form数据 (最好返回一个此订单号)</li><li>使用iframe 将form数据放在页面上—生成二维码</li><li>用户扫码</li><li>展示之后就设定定时器 请求支付结果 ----&gt; 后端出一个接口查询这个支付结果做相应处理</li></ol></li><li>跳转模式（跳转到支付宝收银台,用户扫码支付，如果是移动端就使用支付宝 APP 支付） <ol><li>跟第一种一样 请求接口获取form数据</li><li>跳转至支付宝支付页面</li><li>用户扫码支付</li><li>回调到原来的页面</li><li>接收支付宝回调传的值 请求支付结果接口做操作</li></ol></li></ol></li></ul>',35),k={href:"https://blog.csdn.net/weixin_47284756/article/details/122602293",target:"_blank",rel:"noopener noreferrer"},g=a(`<ul><li>APP <ul><li>前端将订单信息发送给后端 -&gt; 后端返回<code>uni.requestPayment</code>所需数据 -&gt; 前端调用 <code>uni.requestPayment</code>-&gt; 支付成功后</li><li><code>provider：&#39;alipay&#39;</code></li></ul></li></ul><p>银联</p><ul><li>和支付宝一样，都是通过后端返回表单跳转</li></ul><p>【扩展】测试时，前端跳转到银联支付的页面一直是空白页，原因是不能在打开 <code>DevTools</code> 的情况下，打开页面</p><h2 id="_6-你做过哪些项目" tabindex="-1"><a class="header-anchor" href="#_6-你做过哪些项目" aria-hidden="true">#</a> 6. 你做过哪些项目？</h2><p>有亮点、难点的项目，你是怎么解决的？</p><h2 id="_7-你封装过哪些组件或者-hook" tabindex="-1"><a class="header-anchor" href="#_7-你封装过哪些组件或者-hook" aria-hidden="true">#</a> 7. 你封装过哪些组件或者 hook?</h2><p><strong>如何封装组件？</strong></p><ol><li><p>确认动机</p><p>比如，我想减少当前页面的复杂度（为当前页面服务，不太需要考虑通用性）</p><p>比如，我想把这些相同的功能提出去（那就要考虑通用性）</p></li><li><p>分析边界</p><p>越通用的，边界越窄，也就是功能越少，带来的问题越少，越灵活</p></li><li><p>设计接口</p><ul><li>属性</li><li>插槽</li><li>事件</li></ul></li><li><p>代码实现</p></li><li><p>功能测试</p><ul><li>单元测试</li><li>集成测试</li></ul></li><li><p>后续维护</p><ul><li>优化</li><li>bugfix</li><li>功能更新</li></ul></li></ol><p><strong>组件</strong></p><p>像最近我们开发的那个 TF-IEMS 云平台，整个项目的所有页面风格就是类似于大屏展示那种透明化的样式</p><p>我对一些 <code>element plus</code> <strong>常见的表单、表格、弹窗、筛选器、按钮之类的都透明化的二次封装</strong></p><p>并且弹窗也加入可拖拽功能，并且<strong>筛选器也做了 json 配置化的封装</strong>，日期、时间筛选、站点、储能柜筛选只要定好把 json 结构传入就行</p><p>因为，<code>element plus</code> 没有<strong>年份范围选择器、季度选择器</strong>，<strong>时间选择器没有 24:00</strong>,所以也自己写了一个</p><p>比较久项目，以前使用的 <code>element ui</code> <strong>弹窗是没有拖拽功能</strong>的，当时二次封装了一下</p><p><strong>Hook</strong></p><p>写 <code>three 3D</code> 模型的时候，经常是需要通过点击获取然后选择一个模型对象，直接点击就获取到那个模型 <code>threejs</code> 是没有这样的一个 api</p><p>所以我就封装这样的一个<strong>模型选择 <code>hooks</code> 函数</strong></p><p>实现：因为模型坐标是空间坐标，所以需要通过鼠标点击<strong>获取浏览器坐标</strong> -&gt; 设备坐标 -&gt; <strong>世界坐标</strong> -&gt; 序列化</p><p>然后使用射线发射器，与射线相交的第一个模型就是所点击模型</p><p>table 请求 hook、弹窗 hook、分页 hook</p><p>【扩展】</p><p><strong>hooks 与 mixin 有什么区别？</strong></p><p>Vue3 的 hooks 与 Vue2 的 mixin 的差别在于不会覆盖数据</p><p><strong>hooks 与 utils 有什么区别？</strong></p><p>hooks 能引起视图变化，也就是说包含 ref、reactive</p><p>utils 是纯函数</p><p><strong>hook 封装核心？</strong></p><p>核心在与返回值，返回值数据、与操作函数</p><p>table 请求 hook</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useTable</span><span class="token punctuation">(</span><span class="token parameter">api</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token function-variable function">refresh</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">api</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> data<span class="token punctuation">.</span>value <span class="token operator">=</span> res<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> refresh<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-前端项目线上出现紧急的-bug-怎么处理" tabindex="-1"><a class="header-anchor" href="#_8-前端项目线上出现紧急的-bug-怎么处理" aria-hidden="true">#</a> 8. 前端项目线上出现紧急的 bug 怎么处理？</h2><h3 id="_1-定位-bug" tabindex="-1"><a class="header-anchor" href="#_1-定位-bug" aria-hidden="true">#</a> 1. 定位 bug</h3><ul><li>第 1 种 通过 source map 还原线上压缩之后的代码</li><li>第 2 种 用本地的跟线上同版本的代码代理到线上的接口地址</li></ul><h3 id="_2-更新程序" tabindex="-1"><a class="header-anchor" href="#_2-更新程序" aria-hidden="true">#</a> 2. 更新程序</h3><ul><li>第 1 种 通过 websocket 刷新客户端</li><li>第 2 种 通过 轮询 根据前端打包好的 js hash 后缀判断版本是否更新</li></ul><h2 id="_9-webrtc-如何解决内网穿透问题" tabindex="-1"><a class="header-anchor" href="#_9-webrtc-如何解决内网穿透问题" aria-hidden="true">#</a> 9. webRTC 如何解决内网穿透问题？</h2><p>因为视像头需要内网穿透，设备 ip 地址一直是变化的，前端如何拿到设备 ip 地址？</p><p>通过后台返回 ip 设备地址，页面发生变化（关闭重开、刷新、404），重新请求后台获取设备 ip 地址 即可</p><h2 id="_10-echart-开发过程中遇到的问题" tabindex="-1"><a class="header-anchor" href="#_10-echart-开发过程中遇到的问题" aria-hidden="true">#</a> 10. Echart 开发过程中遇到的问题？</h2><ol><li>折线图，<code>series</code> 设置 <code>stack</code> 堆放属性，且属性名一致的话，会导致 y 轴坐标与实际坐标不一样</li></ol><p>解决办法：</p><ul><li>设置 <code>stack</code> 属性为不同值</li><li>去掉 <code>stack</code></li></ul><h2 id="_11-项目上你做过哪些优化" tabindex="-1"><a class="header-anchor" href="#_11-项目上你做过哪些优化" aria-hidden="true">#</a> 11. 项目上你做过哪些优化？</h2><p>项目优化主要是两个方面的优化</p><ul><li>代码层级上的优化</li><li>打包层级上的优化</li></ul><p>代码层级的优化，主要是一些规范性的东西，以及一些优化思路</p><p>打包层级上的优化</p><ul><li>Webpack</li><li>Vite</li></ul><p><strong>webpack4 打包优化【过时 - 用于老项目 vue2】</strong></p><blockquote><p>❌ 表示比较旧的优化方式</p></blockquote><ol><li>分析包大小</li></ol><p>我们可以通过可视化工具，进行分析</p><p>比如，在 <code>build</code> 命令后加 <code>--report</code> ，那么就会在 <code>dist</code> 目录下生成一个 <code>report.html</code>，打开之后就可以用于分析各种包大小 ❌</p><p>也可以通过插件 <code>webpack-bundle-analyzer</code> 来进行分析，效果也是一样的</p><ol start="2"><li><code>externals</code> 提取依赖</li></ol><p>像那些比较大的包，比如 vue、vue-router、axios、echarts 都可以使用，<code>externals</code> 来忽略打包</p><p>然后才用 <code>cdn</code> 的方式引入，需要注意的一点就是 <code>cdn</code> 失效问题，所以做一个 <code>cdn</code> 容灾处理，</p><p>可以采用 <code>document.write</code> 重载资源，或者说使用 <code>HtmlWebpackPlugin</code> 的一些钩子还编写重载资源插件</p><p>其本质就是替换 <code>cdn</code> 链接</p>`,60),_={href:"https://juejin.cn/post/7275943600772644883?searchId=202408091052401EB44F4D157C53E4096D#heading-5",target:"_blank",rel:"noopener noreferrer"},m=a('<ol start="3"><li>组件库的按需引入</li></ol><p>element UI 可以使用 <code>babel-plugin-component</code></p><p>element plus 可以使用 <code>unplugin-vue-components</code> <code>unplugin-auto-import</code></p><ol start="4"><li>第三方依赖按需引入 ❌</li></ol><p>处理时间的一个插件 <code>moment.js</code>，可以使用 <code>moment-locales-webpack-plugin</code> 去除一些没有用到的语言包</p><p>现在的话，我基本上使用 <code>dayjs</code> 代替 <code>moment.js</code></p><p>【扩展】</p><p><code>momentjs</code> 它是一个基于 <code>OOP API</code>（面向原型链编程），所有 <code>api</code> 都挂载到原型链上</p><p>导致无法使用 <code>Webpack</code> 新引入的 <code>Tree-shaking</code> 代码优化技术，无法识别哪些代码是 <code>dead code</code></p><p><code>dayjs</code> 体积小，6.5k</p><p><code>date-fns</code> 纯函数，且支持 ts</p>',11),b=e("thead",null,[e("tr",null,[e("th",null,"名字"),e("th",null,[n("大小("),e("code",null,"gzip"),n(")")]),e("th",null,[n("支持 "),e("code",null,"Tree-shaking")]),e("th",null,"名气"),e("th",null,[e("code",null,"api"),n(" 方法数")]),e("th",null,"模式"),e("th",null,"时区支持"),e("th",null,"支持的语言数")])],-1),f={href:"https://link.segmentfault.com/?enc=P7qviFl%2BylnuL36qvYP2ew%3D%3D.%2BFNt99ZOQQCyLBTUfTEH2ikh2%2FXyL48FrSQ%2F3Sy417L1ZJEZ6ePEq%2FxK3HYdU2YSuSzzL3n7htQbzlJdwcfxxA%3D%3D",target:"_blank",rel:"noopener noreferrer"},v=e("td",null,[e("code",null,"329K(69.6K)")],-1),x=e("td",null,"No",-1),j=e("td",null,[e("code",null,"38k")],-1),w=e("td",null,"高",-1),y=e("td",null,[e("code",null,"OO")],-1),P=e("td",null,[n("非常好("),e("code",null,"moment-timezone"),n(")")],-1),D=e("td",null,"123",-1),A={href:"https://link.segmentfault.com/?enc=AA2l9CDse5DG3BqOXt4kog%3D%3D.yUI%2BQREqRox5S6%2BmJjxgW5mI%2B%2BmOHkc5iLixSATQk4itAhI%2BXADTYRNgw036mH0Df91AR%2FS2kxQTKZt44SHNwQ%3D%3D",target:"_blank",rel:"noopener noreferrer"},S=e("td",null,[e("code",null,"78.4k(13.4k) without tree-shaking")],-1),C=e("td",null,"Yes",-1),E=e("td",null,[e("code",null,"13k")],-1),T=e("td",null,"高",-1),q=e("td",null,[e("code",null,"Functional")],-1),N=e("td",null,"还不支持",-1),B=e("td",null,"32",-1),I={href:"https://link.segmentfault.com/?enc=yCM1MNi13rBKmiFWiKzIlA%3D%3D.89qTpWqOSV2Z6Jr%2BG8wQpWWtUngOu5qJ50rWdjZRDN6ahGY6ur2S2kXSSttn%2BCv%2B0HtTeZqxhKuKx1TfZFCuW%2Fho1qbvaTpgUNAW09xOG%2FM%3D",target:"_blank",rel:"noopener noreferrer"},z=e("td",null,[e("code",null,"6.5k(2.6k) without plugins")],-1),F=e("td",null,"No",-1),W=e("td",null,[e("code",null,"14k")],-1),H=e("td",null,"中",-1),O=e("td",null,[e("code",null,"OO")],-1),M=e("td",null,"还不支持",-1),K=e("td",null,"23",-1),Q=a(`<ol start="5"><li><code>HappyPack</code> 多线程打包 ❌</li></ol><p>开辟一个线程池，通过 <code>os</code> 拿到电脑 CPU 的核数，开启 <code>happypack</code> 将编译工作利用所有线程</p><ol start="6"><li><code>compression-webpack-plugin</code> 开启 <code>webpack</code> <code>gzip</code> 资源压缩</li></ol><p><code>html、js、css</code> 资源，使用 <code>gzip</code> 后通常可以将体积压缩 70%以上</p><p>【扩展】也可以使用 Nginx 配置进行 <code>gzip</code> 压缩</p><ol start="7"><li><code>DllPlugin</code> 动态链接库 ❌</li></ol><p>与 <code>externals</code> 的作用相似</p><p>区别是 <code>DllPlugin</code> 是将依赖单独打包，这样以后每次只构建业务代码</p><p>而 <code>externals</code> 是将依赖转化为 <code>CDN</code> 的方式引入</p><p><strong>webpack5 打包优化【最新】</strong></p><p>主要从两个方面进行优化</p><ul><li><strong>时间层面</strong> 优化打包速度，开发或者构建时优化打包速度（比如 <code>exclude、catch</code> 等）</li><li>**体积层面 ** 优化打包后的结果，上线时的优化（比如分包处理、减小包体积、<code>CDN</code> 服务等）</li></ul><p><strong>优化打包速度</strong></p><p>思路</p><ol><li>定向查找，优化搜索步骤</li></ol><p><code>npm install</code> 安装依赖后，会产生 <code>node_modules</code> 文件夹，webpack 打包的时候会一层层先向上查找文件夹 <code>node_modules</code> 并寻找其引用的第三方模块</p><p>配置 <code>resolve.modules</code> 使用绝对路径指定第三方模块的位置，来从而减少搜索步骤</p><p><code>import</code> 引入模块，如果不带后缀名，就得一个个根据 <code>resolve.extensions</code> 中的预设后缀名进行匹配</p><p>配置 <code>resolve.extensions</code> 减少导入语句的匹配时间</p><ol start="2"><li>减少构建模块</li></ol><p>一些没有模块化的包，比如 <code>lodash</code>（模块化是指☞ 使用了 <code>import、require、export</code> 等模块化语句）</p><p><code>noParse</code> 可以忽略这些包进行构建，如果项目修改起来不麻烦，可以使用 <code>lodash-es</code> 进行代替，这是模块化的包，能进行 <code>Tree-Shaking</code></p><p>比如第三方模块的 <code>moment</code> 包，中有很多语言包，但是我们只需要中文包就行了</p><p><code>IgnorePlugin</code> 可以忽略没用到的包进行构建</p><p>项目中有一些像 <code>vue、vue-router、axios、echarts</code> 比较大的包</p><p><code>externals</code> 可以忽略这些包进行构建，然后我们使用 <code>cdn</code> 的方式进行引入，当然需要做一些 <code>cdn</code> 容灾</p><p>我们在编译 <code>js</code> 文件需要使用 <code>babel-loader</code> ES6 -&gt; ES5</p><p><code>loader</code> 中 <code>include、exclude</code> 去指定需要编译的文件夹，从而减少构建时搜索文件的范围</p><ol start="3"><li>并行构建、压缩</li></ol><p><code>HappyPack、Thread-loader</code>，开启多进程打包</p><p><code>uglifyjs-webpack-plugin（不维护了）、terser-webpack-plugin</code>，开启多进程压缩</p><ol start="4"><li>合理使用缓存</li></ol><p>如果 <code>loader</code> 时间比较长的文件可以采用 <code>bable-loader、cache-loader</code> 开启缓存，进行优化</p><p>使用 <code>webpakck5</code> 新增的 <code>cache.type</code> 来减少开发时的打包时间，生产时会禁用</p><p><strong>优化打包后的结果</strong></p><p>思路</p><ol><li>压缩</li></ol><p><code>html-webpack-plugin</code> 压缩 html</p><p><code>css-minimizer-webpack-plugin</code> 压缩 css</p><p><code>terser-webpack-plugin</code> 压缩 js</p><p><code>image-webpack-loader</code> 压缩图片</p><ol start="2"><li>按需加载</li></ol><p>使用 <code>import()</code> 语法进行按需加载（懒加载）</p><ol start="3"><li>预加载</li></ol><p><code>/* webpackPrefetch: true */</code> 浏览器有空闲时，会帮我们去下载</p><p>【扩展】上家公司是做 <code>PCB</code> 版的嘛，它需要在它的下单页面，展示一个 <code>3D PCB</code> 模型，展示这个模型需要用到一些比较大 <code>js</code> 文件</p><p>所以导致页面加载很慢，但是我就是采用先隐藏这个 <code>3D</code> 模型展示的节点并且用骨架屏替代，然后采用 <code>/* webpackPrefetch: true */</code> 这样一个魔法注释</p><p>这个一个方案编写了加载函数，等这资源加载完成后，再去显示这个模型节点。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">(</span>
  <span class="token comment">/* webpackPrefetch: true */</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">../../3D/threeShow.js</span><span class="token template-punctuation string">\`</span></span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>show3DNode <span class="token operator">=</span> module<span class="token punctuation">.</span>default
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><code>Code Splitting</code> (代码分割)</li></ol><p><code>SplitChunksPlugin</code> 分割 <code>js</code></p><p><code>MiniCssExtractPlugin</code> 分割 <code>css</code></p><p>原理：第一就是拆出来利用浏览器并发请求特性进行快速加载，其次就是多页面如果用到了相同样式能进行复用</p><ol start="5"><li>Tree Shaking</li></ol><p>js Tree Shaking</p><p><code>sideEffects: true</code>，这个生产环境是默认开启的</p><p>但是会导致样式缺失，我们进一步配置</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token property">&quot;sideEffects&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;*.less&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;@babel/polly-fill&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>css Tree Shaking</p><p><code>purgecss-webpack-plugin</code> 插件，没有使用到的 css 会被排除</p><ol start="6"><li>Gzip</li></ol><p><code>compression-webpack-plugin</code> 插件，进行 zip 压缩</p><ol start="7"><li><code>Scope Hoisting</code>（作用域提升）</li></ol><p><code>concatenateModules: true</code>，生产环境默认开启</p><p><strong>分析工具</strong></p><p>时间分析工具：<code> speed-measure-webpack-plugin</code></p><p>构建结果产物分析工具：<code>webpack-bundle-analyzer </code></p><p>参考资料</p>`,68),V={href:"https://juejin.cn/post/7244819106342780988?searchId=202408091446505CA6E1EA3E7795026A46#heading-27",target:"_blank",rel:"noopener noreferrer"},L={href:"https://juejin.cn/post/6996816316875161637?searchId=202408091446505CA6E1EA3E7795026A46",target:"_blank",rel:"noopener noreferrer"},Z={href:"https://juejin.cn/post/7347504184068931619?searchId=202408091825049E65207453A58E13360D#heading-33",target:"_blank",rel:"noopener noreferrer"},U={href:"https://blog.csdn.net/alessia_wang/article/details/122864550",target:"_blank",rel:"noopener noreferrer"},G=a(`<h2 id="_12-threejs-项目难点" tabindex="-1"><a class="header-anchor" href="#_12-threejs-项目难点" aria-hidden="true">#</a> 12. Threejs 项目难点</h2><ol><li>模型获取</li></ol><p>需要创建一个城市模型 blender、blenderGIS 去生成一个城市模型</p><ol start="2"><li>vite 创建 vue 项目，引入 three、tweenjs(动画)</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> init vite@latest
<span class="token function">yarn</span> <span class="token function">add</span> three
<span class="token function">yarn</span> <span class="token function">add</span> @tweenjs/tween.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_13-app-上架流程" tabindex="-1"><a class="header-anchor" href="#_13-app-上架流程" aria-hidden="true">#</a> 13. APP 上架流程？</h2><p>云打包</p><ol><li>uniapp 使用云打包，打包成 APP 包 <ol><li>使用自有证书</li><li>选择正式包</li><li>再配置混淆</li></ol></li><li>到对应的应用商城平台上传就可以了 <ol><li>需要软著</li><li>APP 备案</li><li>名字、截图、描述</li></ol></li></ol><p>离线打包</p><ol><li><code>uniapp</code> 下载离线打包 <code>SDK</code>，生成本地打包资源，用 <code>Android Studio</code>打包</li><li>去 <code>Dcloud</code> 后台，创建应用，获取 <code>AppId、Android ID</code></li><li>修改 <code>uniapp</code> 官方提供的 SDK 包，将 <code>APPID、Android ID</code> 与文件中一些配置进行替换</li><li>然后就能打包了</li></ol><p>【扩展】</p><p>apk 打包体积过大</p><p>可以从减少静态资源、<code>manifest.json</code> 只勾选需要的 APP 权限配置</p><h2 id="_14-骨架屏实现方案" tabindex="-1"><a class="header-anchor" href="#_14-骨架屏实现方案" aria-hidden="true">#</a> 14. 骨架屏实现方案</h2>`,14),R={href:"https://juejin.cn/post/7031446143678726181?searchId=2024102811031548FEAFBEFE69C1D7C6C3",target:"_blank",rel:"noopener noreferrer"},Y=e("h2",{id:"_15-大屏适配方案",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_15-大屏适配方案","aria-hidden":"true"},"#"),n(" 15. 大屏适配方案")],-1),J=e("p",null,[n("大小适配：采用 "),e("code",null,"display: flex; flex:1")],-1),X=e("p",null,"【注】flex 三个属性",-1),$=e("h2",{id:"_16-消息推送",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_16-消息推送","aria-hidden":"true"},"#"),n(" 16. 消息推送")],-1),ee=e("p",null,"websocket、MQTT、SSE",-1);function ne(oe,se){const o=t("ExternalLinkIcon");return p(),c("div",null,[h,e("p",null,[e("a",k,[n("vue pc端支付宝支付-前端需要做的事情_vue调用支付宝-CSDN博客"),s(o)])]),g,e("p",null,[e("a",_,[n("前端 CDN 容灾（资源重载）方案 - 掘金 (juejin.cn)"),s(o)])]),m,e("table",null,[b,e("tbody",null,[e("tr",null,[e("td",null,[e("a",f,[n("Moment.js"),s(o)])]),v,x,j,w,y,P,D]),e("tr",null,[e("td",null,[e("a",A,[n("date-fns"),s(o)])]),S,C,E,T,q,N,B]),e("tr",null,[e("td",null,[e("a",I,[n("dayjs"),s(o)])]),z,F,W,H,O,M,K])])]),Q,e("p",null,[e("a",V,[n("webpack 进阶之性能优化(webpack5 最新版本) - 掘金 (juejin.cn)"),s(o)])]),e("p",null,[e("a",L,[n("学习 Webpack5 之路（优化篇）- 近 7k 字 - 掘金 (juejin.cn)"),s(o)])]),e("p",null,[e("a",Z,[n("面试官：如何进行前端性能优化？ - 掘金 (juejin.cn)"),s(o)])]),e("p",null,[e("a",U,[n("webpackPrefetch: true 属性-CSDN 博客"),s(o)])]),G,e("p",null,[e("a",R,[n("正确使用uniapp搭配微信开发者工具自带的骨架屏功能，生成骨架屏，重点：把index.skeleton.wxml和index.skeleton.wxss文件中 - 掘金"),s(o)])]),Y,J,X,$,ee])}const te=l(u,[["render",ne],["__file","2025前端最新面试题-项目篇（核心）.html.vue"]]);export{te as default};
